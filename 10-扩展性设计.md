# 新闻热点聚合系统 - 扩展性设计

**版本**: v4.0.0  
**文档版本**: 1.0  
**最后更新**: 2025-01-XX

---

## 1. 扩展性概述

### 1.1 扩展性目标

系统设计需要考虑以下扩展场景：

1. **水平扩展**: 支持增加服务器实例
2. **功能扩展**: 易于添加新功能模块
3. **数据扩展**: 支持数据量增长
4. **平台扩展**: 易于添加新的新闻平台
5. **通知渠道扩展**: 易于添加新的通知渠道

### 1.2 扩展性原则

- **模块化设计**: 功能模块独立，易于扩展
- **接口抽象**: 使用接口和抽象类，易于替换实现
- **配置驱动**: 通过配置而非代码扩展功能
- **插件化架构**: 支持插件式扩展

---

## 2. 架构扩展性

### 2.1 Serverless架构优势

Vercel Serverless架构天然支持水平扩展：

```
用户请求增加
    ↓
Vercel自动扩展
    ↓
增加Serverless Functions实例
    ↓
负载均衡
    ↓
处理更多请求
```

**优势**:
- ✅ 自动扩缩容
- ✅ 无需手动配置
- ✅ 按需付费
- ✅ 全球分布

### 2.2 数据库扩展性

Neon PostgreSQL支持自动扩展：

- **连接池**: 自动管理连接
- **读写分离**: 支持只读副本
- **自动备份**: 自动数据备份
- **分支功能**: 支持数据库分支

---

## 3. 功能模块扩展

### 3.1 插件化架构

#### 3.1.1 通知渠道插件

```typescript
// lib/notifiers/base.ts
export interface NotifierPlugin {
  name: string;
  send(message: string, options?: any): Promise<boolean>;
  validateConfig(config: any): boolean;
}

// lib/notifiers/feishu.ts
export class FeishuNotifier implements NotifierPlugin {
  name = 'feishu';
  
  async send(message: string, options?: any): Promise<boolean> {
    // 实现飞书推送
  }
  
  validateConfig(config: any): boolean {
    return !!config.webhookUrl;
  }
}

// lib/notifiers/registry.ts
export class NotifierRegistry {
  private plugins = new Map<string, NotifierPlugin>();
  
  register(plugin: NotifierPlugin) {
    this.plugins.set(plugin.name, plugin);
  }
  
  get(name: string): NotifierPlugin | undefined {
    return this.plugins.get(name);
  }
  
  getAll(): NotifierPlugin[] {
    return Array.from(this.plugins.values());
  }
}

// 使用
const registry = new NotifierRegistry();
registry.register(new FeishuNotifier());
registry.register(new DingtalkNotifier());
// 可以动态注册新插件
```

#### 3.1.2 数据源插件

```typescript
// lib/sources/base.ts
export interface DataSourcePlugin {
  name: string;
  fetchData(options?: any): Promise<NewsItem[]>;
  validateConfig(config: any): boolean;
}

// lib/sources/newsnow.ts
export class NewsNowSource implements DataSourcePlugin {
  name = 'newsnow';
  
  async fetchData(options?: any): Promise<NewsItem[]> {
    // 实现数据获取
  }
  
  validateConfig(config: any): boolean {
    return true;
  }
}

// 可以添加新的数据源
export class CustomAPISource implements DataSourcePlugin {
  name = 'custom-api';
  
  async fetchData(options?: any): Promise<NewsItem[]> {
    // 实现自定义API数据获取
  }
  
  validateConfig(config: any): boolean {
    return !!options.apiUrl && !!options.apiKey;
  }
}
```

### 3.2 配置驱动扩展

```typescript
// lib/config/plugins.ts
export interface PluginConfig {
  name: string;
  enabled: boolean;
  config: Record<string, any>;
}

// 从数据库或配置文件加载插件配置
export async function loadPluginConfigs(): Promise<PluginConfig[]> {
  const configs = await prisma.systemConfig.findMany({
    where: {
      key: { startsWith: 'plugin.' }
    }
  });
  
  return configs.map(config => ({
    name: config.key.replace('plugin.', ''),
    enabled: (config.value as any).enabled ?? true,
    config: config.value as Record<string, any>
  }));
}
```

---

## 4. 数据扩展性

### 4.1 数据分片策略

当数据量增长时，可以考虑分片：

```typescript
// lib/db/sharding.ts
export function getShardKey(date: Date): string {
  // 按月份分片
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  return `news_${year}_${month}`;
}

export async function queryShardedData(
  dateRange: { start: Date; end: Date }
) {
  const shards = getShardsInRange(dateRange);
  const results = await Promise.all(
    shards.map(shard => queryShard(shard, dateRange))
  );
  return results.flat();
}
```

### 4.2 数据归档策略

```typescript
// lib/archive.ts
export async function archiveOldData(retentionDays: number = 90) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
  
  // 归档旧数据到归档表
  await prisma.$executeRaw`
    INSERT INTO news_item_archive
    SELECT * FROM news_item
    WHERE crawled_at < ${cutoffDate}
  `;
  
  // 删除原表数据
  await prisma.newsItem.deleteMany({
    where: {
      crawledAt: { lt: cutoffDate }
    }
  });
}
```

### 4.3 读写分离

```typescript
// lib/db/prisma.ts
// Neon支持只读副本
const readOnlyUrl = process.env.DATABASE_READ_ONLY_URL || process.env.DATABASE_URL;
const writeUrl = process.env.DATABASE_URL;

export const prismaRead = new PrismaClient({
  datasources: { db: { url: readOnlyUrl } }
});

export const prismaWrite = new PrismaClient({
  datasources: { db: { url: writeUrl } }
});

// 使用
const news = await prismaRead.newsItem.findMany(); // 读操作
await prismaWrite.newsItem.create({ data }); // 写操作
```

---

## 5. API扩展性

### 5.1 API版本控制

```typescript
// app/api/v1/news/route.ts
export async function GET(request: Request) {
  // v1 API实现
}

// app/api/v2/news/route.ts
export async function GET(request: Request) {
  // v2 API实现（新版本）
}

// 路由重定向
// app/api/news/route.ts
export async function GET(request: Request) {
  // 默认使用最新版本
  return NextResponse.redirect('/api/v2/news');
}
```

### 5.2 GraphQL支持（可选）

```typescript
// lib/graphql/schema.ts
import { buildSchema } from 'graphql';

export const schema = buildSchema(`
  type NewsItem {
    id: ID!
    title: String!
    url: String
    platform: Platform!
    crawledAt: String!
  }
  
  type Query {
    news(limit: Int, offset: Int): [NewsItem!]!
    newsById(id: ID!): NewsItem
  }
`);

// app/api/graphql/route.ts
export async function POST(request: Request) {
  const { query, variables } = await request.json();
  // 执行GraphQL查询
}
```

---

## 6. 平台扩展

### 6.1 平台配置化

```typescript
// lib/platforms/registry.ts
export interface PlatformConfig {
  id: string;
  name: string;
  enabled: boolean;
  source: 'newsnow' | 'custom';
  sourceConfig: Record<string, any>;
}

// 从数据库加载平台配置
export async function getPlatformConfigs(): Promise<PlatformConfig[]> {
  const configs = await prisma.systemConfig.findOne({
    where: { key: 'platforms' }
  });
  
  return (configs?.value as PlatformConfig[]) ?? [];
}

// 动态添加平台
export async function addPlatform(config: PlatformConfig) {
  await prisma.systemConfig.upsert({
    where: { key: 'platforms' },
    update: {
      value: {
        ...existingPlatforms,
        [config.id]: config
      }
    },
    create: {
      key: 'platforms',
      value: { [config.id]: config }
    }
  });
}
```

### 6.2 平台适配器模式

```typescript
// lib/platforms/adapter.ts
export interface PlatformAdapter {
  fetchData(platformId: string): Promise<NewsItem[]>;
}

export class NewsNowAdapter implements PlatformAdapter {
  async fetchData(platformId: string): Promise<NewsItem[]> {
    // 使用newsnow API
  }
}

export class CustomAPIAdapter implements PlatformAdapter {
  constructor(private config: CustomAPIConfig) {}
  
  async fetchData(platformId: string): Promise<NewsItem[]> {
    // 使用自定义API
  }
}

// 工厂模式
export class PlatformAdapterFactory {
  static create(config: PlatformConfig): PlatformAdapter {
    switch (config.source) {
      case 'newsnow':
        return new NewsNowAdapter();
      case 'custom':
        return new CustomAPIAdapter(config.sourceConfig);
      default:
        throw new Error(`Unknown source: ${config.source}`);
    }
  }
}
```

---

## 7. 通知渠道扩展

### 7.1 通知渠道抽象

```typescript
// lib/notifiers/base.ts
export abstract class BaseNotifier {
  abstract name: string;
  abstract send(message: string, options?: any): Promise<boolean>;
  abstract validateConfig(config: any): boolean;
  
  // 通用方法
  protected formatMessage(message: string): string {
    return message;
  }
  
  protected async retry<T>(
    fn: () => Promise<T>,
    maxRetries: number = 3
  ): Promise<T> {
    // 重试逻辑
  }
}

// 实现具体通知渠道
export class SlackNotifier extends BaseNotifier {
  name = 'slack';
  
  async send(message: string, options?: any): Promise<boolean> {
    // 实现Slack推送
  }
  
  validateConfig(config: any): boolean {
    return !!config.webhookUrl;
  }
}
```

### 7.2 通知渠道配置

```typescript
// 从数据库加载通知配置
export async function getNotifierConfigs(): Promise<Record<string, any>> {
  const config = await prisma.systemConfig.findOne({
    where: { key: 'notification.webhooks' }
  });
  
  return (config?.value as Record<string, any>) ?? {};
}

// 动态添加通知渠道
export async function addNotifierConfig(
  channel: string,
  config: any
) {
  const existing = await getNotifierConfigs();
  
  await prisma.systemConfig.upsert({
    where: { key: 'notification.webhooks' },
    update: {
      value: {
        ...existing,
        [channel]: config
      }
    },
    create: {
      key: 'notification.webhooks',
      value: { [channel]: config }
    }
  });
}
```

---

## 8. 功能扩展示例

### 8.1 添加新功能：新闻分类

```typescript
// 1. 扩展数据模型
// prisma/schema.prisma
model NewsCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  
  newsItems   NewsItem[]
}

model NewsItem {
  // ... 现有字段
  categoryId  String?
  category    NewsCategory? @relation(fields: [categoryId], references: [id])
}

// 2. 创建服务
// lib/services/categorizer.ts
export class CategorizerService {
  async categorizeNews(newsItem: NewsItem): Promise<string | null> {
    // AI分类逻辑
  }
}

// 3. 创建API
// app/api/news/categorize/route.ts
export async function POST(request: Request) {
  // 分类API
}
```

### 8.2 添加新功能：用户收藏

```typescript
// 1. 扩展数据模型
model UserFavorite {
  id        String   @id @default(cuid())
  newsItemId String
  newsItem  NewsItem @relation(fields: [newsItemId], references: [id])
  createdAt DateTime @default(now())
}

// 2. 创建API
// app/api/favorites/route.ts
export async function POST(request: Request) {
  // 添加收藏
}

export async function GET(request: Request) {
  // 查询收藏列表
}
```

---

## 9. 国际化扩展

### 9.1 多语言支持

```typescript
// lib/i18n.ts
import { getRequestConfig } from 'next-intl/server';

export default getRequestConfig(async ({ locale }) => ({
  messages: (await import(`../messages/${locale}.json`)).default
}));

// 使用
import { useTranslations } from 'next-intl';

export function NewsList() {
  const t = useTranslations('News');
  return <h1>{t('title')}</h1>;
}
```

### 9.2 时区支持

```typescript
// lib/timezone.ts
export function formatDate(date: Date, timezone: string = 'Asia/Shanghai'): string {
  return new Intl.DateTimeFormat('zh-CN', {
    timeZone: timezone,
    dateStyle: 'full',
    timeStyle: 'short'
  }).format(date);
}
```

---

## 10. 扩展性最佳实践

### 10.1 设计原则

1. **开闭原则**: 对扩展开放，对修改关闭
2. **依赖倒置**: 依赖抽象而非具体实现
3. **单一职责**: 每个模块只负责一个功能
4. **接口隔离**: 使用小而专的接口

### 10.2 扩展检查清单

- [ ] 新功能是否可以通过配置添加？
- [ ] 新功能是否影响现有功能？
- [ ] 新功能是否需要数据库迁移？
- [ ] 新功能是否需要API版本控制？
- [ ] 新功能是否向后兼容？

---

## 11. 未来扩展方向

### 11.1 计划中的扩展

1. **多用户支持**: 用户认证和授权
2. **移动端App**: React Native应用
3. **实时推送**: WebSocket实时更新
4. **AI分析**: 更深入的AI分析功能
5. **数据导出**: 支持多种格式导出

### 11.2 技术债务管理

- 定期重构代码
- 更新依赖版本
- 优化性能瓶颈
- 改进错误处理

---

## 相关文档

- [02-架构设计.md](./02-架构设计.md) - 架构设计
- [09-性能设计.md](./09-性能设计.md) - 性能优化

