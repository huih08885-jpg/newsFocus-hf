# 新闻热点聚合系统 - 性能设计

**版本**: v4.0.0  
**文档版本**: 1.0  
**最后更新**: 2025-01-XX

---

## 1. 性能概述

### 1.1 性能目标

| 指标 | 目标值 | 说明 |
|------|--------|------|
| API响应时间 | < 200ms | P95响应时间 |
| 页面加载时间 | < 2s | 首屏加载时间 |
| 数据库查询时间 | < 100ms | 单次查询时间 |
| 爬取任务时间 | < 2分钟 | 11个平台完整爬取 |
| 并发处理能力 | > 100 req/s | API并发处理 |

### 1.2 性能优化策略

1. **缓存策略**: 多级缓存，减少数据库查询
2. **数据库优化**: 索引优化，查询优化
3. **代码优化**: 减少不必要的计算，优化算法
4. **网络优化**: CDN加速，压缩传输
5. **异步处理**: 非关键操作异步处理

---

## 2. 缓存策略

### 2.1 多级缓存架构

```
用户请求
    ↓
┌──────────────────────┐
│ 1. 浏览器缓存         │
│    - HTTP缓存头       │
│    - Service Worker  │
└──────────────────────┘
    ↓ 未命中
┌──────────────────────┐
│ 2. Vercel Edge缓存    │
│    - Edge Network    │
│    - 静态资源缓存     │
└──────────────────────┘
    ↓ 未命中
┌──────────────────────┐
│ 3. Vercel KV缓存      │
│    - Redis缓存        │
│    - 热点数据缓存     │
└──────────────────────┘
    ↓ 未命中
┌──────────────────────┐
│ 4. 数据库查询         │
│    - Neon PostgreSQL  │
└──────────────────────┘
```

### 2.2 缓存实现

#### 2.2.1 Vercel KV缓存

```typescript
// lib/cache.ts
import { kv } from '@vercel/kv';

export class CacheService {
  private defaultTTL = 900; // 15分钟

  async get<T>(key: string): Promise<T | null> {
    try {
      const value = await kv.get<T>(key);
      return value;
    } catch (error) {
      console.error('Cache get error:', error);
      return null;
    }
  }

  async set<T>(key: string, value: T, ttl: number = this.defaultTTL): Promise<void> {
    try {
      await kv.setex(key, ttl, JSON.stringify(value));
    } catch (error) {
      console.error('Cache set error:', error);
    }
  }

  async delete(key: string): Promise<void> {
    try {
      await kv.del(key);
    } catch (error) {
      console.error('Cache delete error:', error);
    }
  }

  async invalidate(pattern: string): Promise<void> {
    // 根据模式删除缓存
    const keys = await kv.keys(pattern);
    if (keys.length > 0) {
      await kv.del(...keys);
    }
  }
}

export const cache = new CacheService();
```

#### 2.2.2 缓存使用示例

```typescript
// app/api/news/route.ts
import { cache } from '@/lib/cache';

export async function GET(request: Request) {
  const cacheKey = `news:${JSON.stringify(queryParams)}`;
  
  // 尝试从缓存获取
  const cached = await cache.get(cacheKey);
  if (cached) {
    return NextResponse.json({ success: true, data: cached });
  }
  
  // 查询数据库
  const data = await prisma.newsItem.findMany({ ... });
  
  // 写入缓存
  await cache.set(cacheKey, data, 900); // 15分钟
  
  return NextResponse.json({ success: true, data });
}
```

### 2.3 缓存策略配置

```typescript
// lib/cache-strategies.ts
export const cacheStrategies = {
  // 最新新闻：5分钟缓存
  latestNews: { ttl: 300 },
  
  // 历史新闻：30分钟缓存
  historicalNews: { ttl: 1800 },
  
  // 统计数据：15分钟缓存
  statistics: { ttl: 900 },
  
  // 配置数据：1小时缓存
  config: { ttl: 3600 },
  
  // 平台列表：1天缓存
  platforms: { ttl: 86400 }
};
```

---

## 3. 数据库优化

### 3.1 索引优化

#### 3.1.1 查询索引

```prisma
// prisma/schema.prisma
model NewsItem {
  // ... 字段定义
  
  @@index([platformId, crawledAt]) // 复合索引：按平台和时间查询
  @@index([title]) // 单列索引：标题搜索
  @@index([crawledAt]) // 单列索引：时间范围查询
}

model NewsMatch {
  // ... 字段定义
  
  @@index([keywordGroupId, weight]) // 复合索引：按词组和权重查询
  @@index([lastMatchedAt]) // 单列索引：时间查询
}
```

#### 3.1.2 索引使用分析

```typescript
// 使用EXPLAIN分析查询
const result = await prisma.$queryRaw`
  EXPLAIN ANALYZE
  SELECT * FROM "NewsItem"
  WHERE "platformId" = 'zhihu'
  AND "crawledAt" >= NOW() - INTERVAL '1 hour'
  ORDER BY "crawledAt" DESC
  LIMIT 50
`;
```

### 3.2 查询优化

#### 3.2.1 选择字段

```typescript
// ✅ 优化：只选择需要的字段
const news = await prisma.newsItem.findMany({
  select: {
    id: true,
    title: true,
    url: true,
    crawledAt: true
  }
});

// ❌ 不优化：选择所有字段
const news = await prisma.newsItem.findMany();
```

#### 3.2.2 分页查询

```typescript
// ✅ 优化：使用cursor分页
const news = await prisma.newsItem.findMany({
  take: 50,
  cursor: { id: lastId },
  skip: 1,
  orderBy: { id: 'asc' }
});

// ❌ 不优化：使用offset分页（大数据集性能差）
const news = await prisma.newsItem.findMany({
  take: 50,
  skip: offset
});
```

#### 3.2.3 批量操作

```typescript
// ✅ 优化：批量插入
await prisma.newsItem.createMany({
  data: newsItems,
  skipDuplicates: true
});

// ❌ 不优化：循环插入
for (const item of newsItems) {
  await prisma.newsItem.create({ data: item });
}
```

### 3.3 连接池优化

```typescript
// lib/db/prisma.ts
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
    datasources: {
      db: {
        url: process.env.DATABASE_URL + '?connection_limit=10&pool_timeout=20'
      }
    }
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

---

## 4. 代码优化

### 4.1 算法优化

#### 4.1.1 关键词匹配优化

```typescript
// lib/services/matcher.ts
export class MatcherService {
  private keywordGroupsCache: KeywordGroup[] | null = null;
  private cacheExpiry = 0;
  private CACHE_TTL = 60000; // 1分钟

  async getEnabledKeywordGroups(): Promise<KeywordGroup[]> {
    const now = Date.now();
    
    // 使用内存缓存
    if (this.keywordGroupsCache && now < this.cacheExpiry) {
      return this.keywordGroupsCache;
    }
    
    const groups = await prisma.keywordGroup.findMany({
      where: { enabled: true },
      orderBy: { priority: 'asc' }
    });
    
    this.keywordGroupsCache = groups;
    this.cacheExpiry = now + this.CACHE_TTL;
    
    return groups;
  }

  // 使用Map优化匹配性能
  async matchNewsItems(newsItems: NewsItem[]): Promise<Map<string, KeywordGroup[]>> {
    const groups = await this.getEnabledKeywordGroups();
    const matches = new Map<string, KeywordGroup[]>();
    
    // 预处理：构建关键词索引
    const keywordIndex = this.buildKeywordIndex(groups);
    
    for (const item of newsItems) {
      const matchedGroups = this.matchTitleOptimized(item.title, groups, keywordIndex);
      if (matchedGroups.length > 0) {
        matches.set(item.id, matchedGroups);
      }
    }
    
    return matches;
  }

  private buildKeywordIndex(groups: KeywordGroup[]): Map<string, KeywordGroup[]> {
    const index = new Map<string, KeywordGroup[]>();
    
    for (const group of groups) {
      for (const word of group.words) {
        if (!index.has(word)) {
          index.set(word, []);
        }
        index.get(word)!.push(group);
      }
    }
    
    return index;
  }
}
```

#### 4.1.2 权重计算优化

```typescript
// lib/services/calculator.ts
export class CalculatorService {
  // 批量计算权重，减少数据库查询
  async calculateWeightsBatch(matchIds: string[]): Promise<Map<string, number>> {
    // 一次性查询所有需要的数据
    const matches = await prisma.newsMatch.findMany({
      where: { id: { in: matchIds } },
      include: {
        appearances: true
      }
    });
    
    const weights = new Map<string, number>();
    
    for (const match of matches) {
      const weight = this.calculateWeight({
        ranks: match.appearances.map(a => a.rank),
        matchCount: match.matchCount,
        appearances: match.appearances
      });
      weights.set(match.id, weight);
    }
    
    // 批量更新
    await Promise.all(
      Array.from(weights.entries()).map(([id, weight]) =>
        prisma.newsMatch.update({
          where: { id },
          data: { weight }
        })
      )
    );
    
    return weights;
  }
}
```

### 4.2 异步处理

```typescript
// lib/services/crawler.ts
export class CrawlerService {
  // 并发爬取（控制并发数）
  async crawlAllPlatformsConcurrent(
    concurrency: number = 3
  ): Promise<CrawlResult[]> {
    const platforms = await this.getEnabledPlatforms();
    const results: CrawlResult[] = [];
    
    // 分批处理
    for (let i = 0; i < platforms.length; i += concurrency) {
      const batch = platforms.slice(i, i + concurrency);
      
      const batchResults = await Promise.all(
        batch.map(platform => this.fetchPlatformData(platform.id))
      );
      
      results.push(...batchResults);
      
      // 批次间延迟
      if (i + concurrency < platforms.length) {
        await this.delay(this.requestInterval);
      }
    }
    
    return results;
  }
}
```

### 4.3 内存优化

```typescript
// 流式处理大数据集
async function* processNewsItemsStream() {
  let cursor: string | undefined;
  
  while (true) {
    const batch = await prisma.newsItem.findMany({
      take: 1000,
      ...(cursor && { cursor: { id: cursor }, skip: 1 }),
      orderBy: { id: 'asc' }
    });
    
    if (batch.length === 0) break;
    
    for (const item of batch) {
      yield item;
    }
    
    cursor = batch[batch.length - 1].id;
  }
}

// 使用
for await (const item of processNewsItemsStream()) {
  // 处理单个item，不占用大量内存
  await processItem(item);
}
```

---

## 5. 网络优化

### 5.1 CDN配置

Vercel自动提供CDN，但可以优化：

```typescript
// next.config.js
module.exports = {
  // 静态资源缓存
  async headers() {
    return [
      {
        source: '/images/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable'
          }
        ]
      },
      {
        source: '/api/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, s-maxage=60, stale-while-revalidate=300'
          }
        ]
      }
    ];
  }
};
```

### 5.2 数据压缩

```typescript
// next.config.js
module.exports = {
  compress: true, // 启用gzip压缩
  // ...
};
```

### 5.3 图片优化

```typescript
// next.config.js
module.exports = {
  images: {
    formats: ['image/avif', 'image/webp'],
    domains: ['example.com'],
    // 使用Next.js Image组件自动优化
  }
};
```

---

## 6. 前端性能优化

### 6.1 Server Components

```typescript
// app/news/page.tsx
// Server Component，在服务端渲染，减少客户端JS
export default async function NewsPage() {
  const news = await prisma.newsItem.findMany({
    take: 50,
    orderBy: { crawledAt: 'desc' }
  });
  
  return (
    <div>
      {news.map(item => (
        <NewsCard key={item.id} news={item} />
      ))}
    </div>
  );
}
```

### 6.2 代码分割

```typescript
// 动态导入，按需加载
import dynamic from 'next/dynamic';

const Chart = dynamic(() => import('@/components/Chart'), {
  ssr: false,
  loading: () => <div>Loading chart...</div>
});
```

### 6.3 预加载

```typescript
// 预加载关键资源
import Link from 'next/link';

<Link href="/news" prefetch={true}>
  News
</Link>
```

---

## 7. 监控和测量

### 7.1 性能监控

```typescript
// lib/performance.ts
export function measurePerformance<T>(
  name: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = performance.now();
  
  return fn().finally(() => {
    const duration = performance.now() - start;
    console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);
    
    // 发送到监控服务
    // sendMetric(name, duration);
  });
}

// 使用
const news = await measurePerformance('fetchNews', async () => {
  return await prisma.newsItem.findMany();
});
```

### 7.2 数据库查询监控

```typescript
// lib/db/prisma.ts
const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
  ],
});

prisma.$on('query', (e) => {
  if (e.duration > 100) {
    console.warn(`Slow query: ${e.query} (${e.duration}ms)`);
  }
});
```

### 7.3 Vercel Analytics

```typescript
// app/layout.tsx
import { Analytics } from '@vercel/analytics/react';
import { SpeedInsights } from '@vercel/speed-insights/next';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}
```

---

## 8. 性能测试

### 8.1 负载测试

```typescript
// scripts/load-test.ts
import { performance } from 'perf_hooks';

async function loadTest() {
  const iterations = 100;
  const times: number[] = [];
  
  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    await fetch('http://localhost:3000/api/news');
    const duration = performance.now() - start;
    times.push(duration);
  }
  
  const avg = times.reduce((a, b) => a + b, 0) / times.length;
  const p95 = times.sort()[Math.floor(times.length * 0.95)];
  const p99 = times.sort()[Math.floor(times.length * 0.99)];
  
  console.log(`Average: ${avg.toFixed(2)}ms`);
  console.log(`P95: ${p95.toFixed(2)}ms`);
  console.log(`P99: ${p99.toFixed(2)}ms`);
}
```

### 8.2 数据库性能测试

```sql
-- 分析慢查询
EXPLAIN ANALYZE
SELECT * FROM "NewsItem"
WHERE "platformId" = 'zhihu'
AND "crawledAt" >= NOW() - INTERVAL '1 hour'
ORDER BY "crawledAt" DESC
LIMIT 50;

-- 检查索引使用
SELECT 
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;
```

---

## 9. 性能优化清单

### 9.1 数据库优化

- [ ] 添加必要的索引
- [ ] 优化慢查询
- [ ] 使用连接池
- [ ] 批量操作替代循环
- [ ] 使用cursor分页

### 9.2 缓存优化

- [ ] 实现多级缓存
- [ ] 设置合理的TTL
- [ ] 缓存失效策略
- [ ] 使用CDN缓存

### 9.3 代码优化

- [ ] 算法优化
- [ ] 减少不必要的计算
- [ ] 异步处理非关键操作
- [ ] 代码分割和懒加载

### 9.4 网络优化

- [ ] 启用压缩
- [ ] 优化图片
- [ ] 使用CDN
- [ ] HTTP/2支持

---

## 相关文档

- [07-部署架构.md](./07-部署架构.md) - 部署架构
- [10-扩展性设计.md](./10-扩展性设计.md) - 扩展性设计

