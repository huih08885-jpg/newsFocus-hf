# 新闻热点聚合系统 - 核心模块设计

**版本**: v4.0.0  
**文档版本**: 1.0  
**最后更新**: 2025-01-XX

---

## 1. 模块概述

系统采用模块化设计，每个模块负责特定的业务功能。主要模块包括：

1. **爬虫服务模块** (CrawlerService)
2. **关键词匹配模块** (MatcherService)
3. **权重计算模块** (CalculatorService)
4. **报告生成模块** (ReportService)
5. **通知推送模块** (NotifierService)
6. **数据服务模块** (DataService)

---

## 2. 爬虫服务模块 (CrawlerService)

### 2.1 模块职责

- 从外部API爬取新闻数据
- 错误处理和重试机制
- 代理支持
- 数据存储到数据库

### 2.2 类设计

```typescript
// lib/services/crawler.ts

import { PrismaClient } from '@prisma/client';

interface CrawlResult {
  success: boolean;
  platformId: string;
  data?: NewsItem[];
  error?: string;
}

interface NewsItem {
  title: string;
  url?: string;
  mobileUrl?: string;
  rank: number;
}

export class CrawlerService {
  private prisma: PrismaClient;
  private baseUrl = 'https://newsnow.busiyi.world/api/s';
  private requestInterval: number;
  private proxyUrl?: string;

  constructor(
    prisma: PrismaClient,
    options?: {
      requestInterval?: number;
      proxyUrl?: string;
    }
  ) {
    this.prisma = prisma;
    this.requestInterval = options?.requestInterval ?? 1000;
    this.proxyUrl = options?.proxyUrl;
  }

  /**
   * 爬取单个平台数据
   */
  async fetchPlatformData(
    platformId: string,
    maxRetries: number = 2
  ): Promise<CrawlResult> {
    // 实现爬取逻辑
  }

  /**
   * 爬取所有启用的平台
   */
  async crawlAllPlatforms(): Promise<{
    successCount: number;
    failedCount: number;
    results: CrawlResult[];
  }> {
    // 实现批量爬取逻辑
  }

  /**
   * 保存新闻数据到数据库
   */
  private async saveNewsItems(
    platformId: string,
    items: NewsItem[]
  ): Promise<void> {
    // 实现保存逻辑
  }

  /**
   * HTTP请求（带重试）
   */
  private async fetchWithRetry(
    url: string,
    maxRetries: number = 2
  ): Promise<Response> {
    // 实现重试逻辑
  }
}
```

### 2.3 核心方法

#### 2.3.1 fetchPlatformData

**功能**: 爬取单个平台数据

**流程**:
1. 构建请求URL
2. 发送HTTP请求（带重试）
3. 解析响应JSON
4. 验证数据格式
5. 保存到数据库
6. 返回结果

**错误处理**:
- 网络错误：重试最多2次
- 解析错误：记录错误信息
- 数据验证错误：跳过无效数据

#### 2.3.2 crawlAllPlatforms

**功能**: 爬取所有启用的平台

**流程**:
1. 查询所有启用的平台
2. 遍历平台列表
3. 调用 `fetchPlatformData`
4. 控制请求间隔
5. 统计成功和失败数量
6. 返回汇总结果

### 2.4 使用示例

```typescript
import { PrismaClient } from '@prisma/client';
import { CrawlerService } from '@/lib/services/crawler';

const prisma = new PrismaClient();
const crawler = new CrawlerService(prisma, {
  requestInterval: 1000,
  proxyUrl: process.env.PROXY_URL
});

// 爬取所有平台
const result = await crawler.crawlAllPlatforms();
console.log(`成功: ${result.successCount}, 失败: ${result.failedCount}`);
```

---

## 3. 关键词匹配模块 (MatcherService)

### 3.1 模块职责

- 关键词组解析
- 新闻标题匹配
- 匹配规则处理（普通词、必须词、过滤词）

### 3.2 类设计

```typescript
// lib/services/matcher.ts

interface KeywordGroup {
  id: string;
  name?: string;
  words: string[];           // 普通词
  requiredWords: string[];   // 必须词（带+前缀）
  excludedWords: string[];    // 过滤词（带!前缀）
  priority: number;
  enabled: boolean;
}

interface MatchResult {
  matched: boolean;
  keywordGroup?: KeywordGroup;
  matchedWords?: string[];
}

export class MatcherService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * 获取所有启用的关键词组
   */
  async getEnabledKeywordGroups(): Promise<KeywordGroup[]> {
    // 从数据库查询启用的关键词组
  }

  /**
   * 匹配新闻标题
   */
  async matchTitle(
    title: string,
    keywordGroups?: KeywordGroup[]
  ): Promise<MatchResult | null> {
    // 实现匹配逻辑
  }

  /**
   * 批量匹配新闻
   */
  async matchNewsItems(
    newsItems: Array<{ id: string; title: string }>
  ): Promise<Map<string, KeywordGroup[]>> {
    // 批量匹配，返回新闻ID到关键词组的映射
  }

  /**
   * 检查标题是否匹配词组
   */
  private matchesGroup(
    title: string,
    group: KeywordGroup
  ): MatchResult {
    // 实现匹配算法
  }
}
```

### 3.3 匹配算法

#### 3.3.1 匹配流程

```
1. 遍历所有启用的关键词组（按优先级排序）
2. 对于每个词组：
   a. 检查普通词匹配（标题包含任意一个普通词）
   b. 如果存在必须词，检查是否包含所有必须词
   c. 检查是否包含过滤词（如果包含则排除）
   d. 如果全部通过，返回匹配结果
3. 如果没有匹配，返回null
```

#### 3.3.2 匹配规则示例

```typescript
// 普通词匹配
words: ["AI", "人工智能"]
// 标题包含 "AI" 或 "人工智能" 即匹配

// 必须词匹配
words: ["华为", "OPPO"]
requiredWords: ["手机"]
// 标题必须同时包含 "华为" 或 "OPPO" 以及 "手机"

// 过滤词匹配
words: ["苹果"]
excludedWords: ["水果", "价格"]
// 标题包含 "苹果" 但不包含 "水果" 和 "价格"
```

### 3.4 使用示例

```typescript
import { MatcherService } from '@/lib/services/matcher';

const matcher = new MatcherService(prisma);

// 匹配单个标题
const result = await matcher.matchTitle("华为发布新款手机");
if (result?.matched) {
  console.log(`匹配到关键词组: ${result.keywordGroup?.name}`);
}

// 批量匹配
const newsItems = await prisma.newsItem.findMany({ take: 100 });
const matches = await matcher.matchNewsItems(newsItems);
```

---

## 4. 权重计算模块 (CalculatorService)

### 4.1 模块职责

- 计算新闻权重分数
- 多维度权重算法
- 权重配置管理

### 4.2 类设计

```typescript
// lib/services/calculator.ts

interface WeightConfig {
  rankWeight: number;      // 排名权重（默认0.6）
  frequencyWeight: number; // 频次权重（默认0.3）
  hotnessWeight: number;   // 热度权重（默认0.1）
}

interface NewsMatchData {
  newsItemId: string;
  keywordGroupId: string;
  ranks: number[];         // 排名列表
  matchCount: number;      // 匹配次数
  appearances: Array<{
    rank: number;
    appearedAt: Date;
  }>;
}

export class CalculatorService {
  private config: WeightConfig;

  constructor(config?: Partial<WeightConfig>) {
    this.config = {
      rankWeight: config?.rankWeight ?? 0.6,
      frequencyWeight: config?.frequencyWeight ?? 0.3,
      hotnessWeight: config?.hotnessWeight ?? 0.1,
    };
  }

  /**
   * 计算新闻权重
   */
  calculateWeight(
    data: NewsMatchData,
    rankThreshold: number = 5
  ): number {
    // 实现权重计算
  }

  /**
   * 计算排名权重分数
   */
  private calculateRankScore(
    ranks: number[],
    rankThreshold: number
  ): number {
    // 排名权重 = Σ(11 - min(rank, 10)) / 出现次数
  }

  /**
   * 计算频次权重分数
   */
  private calculateFrequencyScore(
    matchCount: number
  ): number {
    // 频次权重 = min(出现次数, 10) × 10
  }

  /**
   * 计算热度权重分数
   */
  private calculateHotnessScore(
    appearances: Array<{ rank: number }>,
    totalCount: number
  ): number {
    // 热度权重 = (高排名次数 / 总出现次数) × 100
  }
}
```

### 4.3 权重计算公式

#### 4.3.1 排名权重 (60%)

```
rank_score = Σ(11 - min(rank, 10)) / 出现次数

示例：
排名列表: [1, 2, 3]
rank_score = ((11-1) + (11-2) + (11-3)) / 3 = 27 / 3 = 9
```

#### 4.3.2 频次权重 (30%)

```
frequency_score = min(出现次数, 10) × 10

示例：
出现次数: 5
frequency_score = min(5, 10) × 10 = 50
```

#### 4.3.3 热度权重 (10%)

```
hotness_score = (高排名次数 / 总出现次数) × 100

示例：
总出现次数: 10
高排名次数（rank <= 5）: 7
hotness_score = (7 / 10) × 100 = 70
```

#### 4.3.4 总权重

```
total_weight = rank_score × 0.6 + frequency_score × 0.3 + hotness_score × 0.1

示例：
rank_score = 9
frequency_score = 50
hotness_score = 70
total_weight = 9 × 0.6 + 50 × 0.3 + 70 × 0.1 = 5.4 + 15 + 7 = 27.4
```

### 4.4 使用示例

```typescript
import { CalculatorService } from '@/lib/services/calculator';

const calculator = new CalculatorService({
  rankWeight: 0.6,
  frequencyWeight: 0.3,
  hotnessWeight: 0.1
});

const weight = calculator.calculateWeight({
  newsItemId: 'xxx',
  keywordGroupId: 'yyy',
  ranks: [1, 2, 3],
  matchCount: 3,
  appearances: [
    { rank: 1, appearedAt: new Date() },
    { rank: 2, appearedAt: new Date() },
    { rank: 3, appearedAt: new Date() }
  ]
}, 5);

console.log(`权重分数: ${weight}`);
```

---

## 5. 报告生成模块 (ReportService)

### 5.1 模块职责

- 生成HTML报告
- 格式化消息内容（各渠道格式）
- 报告模板管理

### 5.2 类设计

```typescript
// lib/services/report.ts

interface ReportData {
  reportType: 'daily' | 'current' | 'incremental';
  stats: Array<{
    keywordGroup: KeywordGroup;
    count: number;
    percentage: number;
    newsItems: Array<{
      newsItem: NewsItem;
      weight: number;
      isNew: boolean;
    }>;
  }>;
  newItems: NewsItem[];
  totalCount: number;
  matchedCount: number;
  generatedAt: Date;
}

export class ReportService {
  /**
   * 生成HTML报告
   */
  async generateHTMLReport(data: ReportData): Promise<string> {
    // 生成HTML内容
  }

  /**
   * 生成飞书消息格式
   */
  generateFeishuMessage(data: ReportData): string {
    // 生成飞书富文本格式
  }

  /**
   * 生成钉钉消息格式
   */
  generateDingtalkMessage(data: ReportData): string {
    // 生成钉钉Markdown格式
  }

  /**
   * 生成企业微信消息格式
   */
  generateWeworkMessage(data: ReportData): string {
    // 生成企业微信Markdown格式
  }

  /**
   * 生成Telegram消息格式
   */
  generateTelegramMessage(data: ReportData): string {
    // 生成Telegram HTML格式
  }

  /**
   * 生成邮件内容
   */
  generateEmailContent(data: ReportData): {
    subject: string;
    html: string;
    text: string;
  } {
    // 生成邮件内容
  }

  /**
   * 生成ntfy消息格式
   */
  generateNtfyMessage(data: ReportData): string {
    // 生成ntfy文本格式
  }

  /**
   * 分批处理消息
   */
  splitMessage(
    message: string,
    maxLength: number
  ): string[] {
    // 按长度分批
  }
}
```

### 5.3 报告模板

#### 5.3.1 HTML报告模板结构

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>新闻热点报告</title>
  <style>/* 样式 */</style>
</head>
<body>
  <header>
    <h1>报告类型</h1>
    <p>生成时间: {generatedAt}</p>
    <p>新闻总数: {totalCount}</p>
    <p>匹配数量: {matchedCount}</p>
  </header>
  
  <section class="stats">
    <h2>热点词汇统计</h2>
    <!-- 统计数据 -->
  </section>
  
  <section class="news-list">
    <h2>新闻列表</h2>
    <!-- 新闻列表 -->
  </section>
  
  <section class="new-items">
    <h2>新增新闻</h2>
    <!-- 新增新闻 -->
  </section>
  
  <footer>
    <p>Generated by NewsFocus</p>
  </footer>
</body>
</html>
```

### 5.4 使用示例

```typescript
import { ReportService } from '@/lib/services/report';

const reportService = new ReportService();

// 生成HTML报告
const html = await reportService.generateHTMLReport(reportData);

// 生成飞书消息
const feishuMsg = reportService.generateFeishuMessage(reportData);

// 分批处理
const batches = reportService.splitMessage(feishuMsg, 29000);
```

---

## 6. 通知推送模块 (NotifierService)

### 6.1 模块职责

- 多渠道消息推送
- 推送时间窗口控制
- 推送记录管理
- 错误处理和重试

### 6.2 类设计

```typescript
// lib/services/notifier.ts

interface NotificationConfig {
  feishu?: { webhookUrl: string };
  dingtalk?: { webhookUrl: string };
  wework?: { webhookUrl: string };
  telegram?: { botToken: string; chatId: string };
  email?: {
    from: string;
    password: string;
    to: string[];
    smtpServer: string;
    smtpPort: number;
  };
  ntfy?: {
    serverUrl: string;
    topic: string;
    token?: string;
  };
}

interface PushWindowConfig {
  enabled: boolean;
  timeRange: {
    start: string; // "20:00"
    end: string;   // "22:00"
  };
  oncePerDay: boolean;
}

export class NotifierService {
  private prisma: PrismaClient;
  private config: NotificationConfig;
  private pushWindow: PushWindowConfig;

  constructor(
    prisma: PrismaClient,
    config: NotificationConfig,
    pushWindow?: PushWindowConfig
  ) {
    this.prisma = prisma;
    this.config = config;
    this.pushWindow = pushWindow ?? {
      enabled: false,
      timeRange: { start: '00:00', end: '23:59' },
      oncePerDay: false
    };
  }

  /**
   * 发送通知到所有配置的渠道
   */
  async sendNotifications(
    message: string,
    reportType: string,
    reportDate: Date
  ): Promise<{
    success: string[];
    failed: Array<{ channel: string; error: string }>;
  }> {
    // 检查推送时间窗口
    // 检查推送记录
    // 发送到各渠道
    // 记录推送状态
  }

  /**
   * 发送飞书消息
   */
  private async sendFeishu(message: string): Promise<boolean> {
    // 实现飞书推送
  }

  /**
   * 发送钉钉消息
   */
  private async sendDingtalk(message: string): Promise<boolean> {
    // 实现钉钉推送
  }

  /**
   * 发送企业微信消息
   */
  private async sendWework(message: string): Promise<boolean> {
    // 实现企业微信推送
  }

  /**
   * 发送Telegram消息
   */
  private async sendTelegram(message: string): Promise<boolean> {
    // 实现Telegram推送
  }

  /**
   * 发送邮件
   */
  private async sendEmail(
    subject: string,
    html: string,
    text: string
  ): Promise<boolean> {
    // 实现邮件发送
  }

  /**
   * 发送ntfy消息
   */
  private async sendNtfy(message: string): Promise<boolean> {
    // 实现ntfy推送
  }

  /**
   * 检查推送时间窗口
   */
  private isInPushWindow(): boolean {
    // 检查当前时间是否在推送窗口内
  }

  /**
   * 检查今天是否已推送
   */
  private async hasPushedToday(
    channel: string,
    reportType: string,
    reportDate: Date
  ): Promise<boolean> {
    // 查询推送记录
  }
}
```

### 6.3 推送流程

```
1. 检查推送时间窗口
   ↓
2. 检查推送记录（如果启用once_per_day）
   ↓
3. 生成消息内容
   ↓
4. 分批处理（如果超过限制）
   ↓
5. 发送到各渠道
   ↓
6. 记录推送状态
```

### 6.4 使用示例

```typescript
import { NotifierService } from '@/lib/services/notifier';

const notifier = new NotifierService(prisma, {
  feishu: { webhookUrl: process.env.FEISHU_WEBHOOK_URL! },
  dingtalk: { webhookUrl: process.env.DINGTALK_WEBHOOK_URL! }
}, {
  enabled: true,
  timeRange: { start: '20:00', end: '22:00' },
  oncePerDay: true
});

const result = await notifier.sendNotifications(
  message,
  'daily',
  new Date()
);
```

---

## 7. 数据服务模块 (DataService)

### 7.1 模块职责

- 统一数据访问接口
- 数据查询和筛选
- 统计数据计算

### 7.2 类设计

```typescript
// lib/services/data.ts

export class DataService {
  private prisma: PrismaClient;

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  /**
   * 获取最新新闻
   */
  async getLatestNews(options?: {
    platforms?: string[];
    limit?: number;
    includeUrl?: boolean;
  }): Promise<NewsItem[]> {
    // 查询最新新闻
  }

  /**
   * 按日期查询新闻
   */
  async getNewsByDate(
    date: Date,
    options?: {
      platforms?: string[];
      limit?: number;
    }
  ): Promise<NewsItem[]> {
    // 按日期查询
  }

  /**
   * 查询匹配的新闻
   */
  async getMatchedNews(options?: {
    keywordGroupId?: string;
    minWeight?: number;
    dateRange?: { start: Date; end: Date };
    limit?: number;
  }): Promise<Array<NewsMatch & { newsItem: NewsItem }>> {
    // 查询匹配的新闻
  }

  /**
   * 获取统计数据
   */
  async getStatistics(options?: {
    dateRange?: { start: Date; end: Date };
    keywordGroupId?: string;
  }): Promise<Statistics> {
    // 计算统计数据
  }
}
```

---

## 8. 模块集成

### 8.1 API Route集成示例

```typescript
// app/api/crawl/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { CrawlerService } from '@/lib/services/crawler';
import { MatcherService } from '@/lib/services/matcher';
import { CalculatorService } from '@/lib/services/calculator';

const prisma = new PrismaClient();

export async function POST(request: NextRequest) {
  try {
    // 1. 爬取数据
    const crawler = new CrawlerService(prisma);
    const crawlResult = await crawler.crawlAllPlatforms();

    // 2. 匹配关键词
    const matcher = new MatcherService(prisma);
    const newsItems = await prisma.newsItem.findMany({
      where: { crawledAt: { gte: new Date(Date.now() - 3600000) } }
    });
    const matches = await matcher.matchNewsItems(newsItems);

    // 3. 计算权重
    const calculator = new CalculatorService();
    // ... 计算权重并保存

    return NextResponse.json({ success: true, crawlResult });
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

---

## 相关文档

- [02-架构设计.md](./02-架构设计.md) - 架构设计
- [04-数据模型设计.md](./04-数据模型设计.md) - 数据模型设计
- [05-接口设计.md](./05-接口设计.md) - API接口设计

